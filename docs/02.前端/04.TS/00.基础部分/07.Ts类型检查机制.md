---
title: Ts类型检查机制
date: 2022-04-01 08:38:18
permalink: /pages/e15049/
categories: 
  - 前端
  - TS
  - 基础部分
author: 
  name: 冯亮
  link: https://github.com/776488326
titleTag: 原创
---
# 类型检查机制

## 介绍

- 编译器在做类型检查时，遵循的一些原则

### 类型推断

- 不需要指定变量的类型或者函数返回值的类型，typescript会自动根据某些规则进行推断

1. 基础类型推断
    - 设置变量的值，或者变量的默认值，或者函数的返回值时，会自动根据值进行类型推断
2. 最佳通用类型推断
    - 当需要从多个类型中推断一个类型时，会尽可能推断出兼容当前所有类型的通用类型
3. 上下文类型推断
    - 通常发生在事件处理中，根据左侧的事件绑定，来推断右侧参数的类型
4. 任意类型推断
    - 当一个变量在声明时没有指定类型，同时也没有初始化，则推断为any类型。之后再赋值也无法改变类型

### 类型兼容性

- 当一个类型的变量Y可以被赋值给另一个类型的变量X时，可以称这两种类型兼容，X（目标类型）兼容Y（源类型）。

1. 接口的兼容性
    - 接口间相互兼容时，成员少的会兼容成员多的。
2. 函数的兼容性
    - 函数间互相赋值时，参数多的会兼容参数少的，参数类型必须匹配。
    - 固定参数可以兼容可选参数和剩余参数的。
    - 可选参数不兼容固定参数和剩余参数的。
    - 剩余参数可以兼容可选参数和固定参数。
    - 返回值兼容，要求目标函数的返回值必须是源函数的返回值类型或者为其子类型。
    - 重载函数中，重载声明看作是目标函数，函数的定义看作是源函数。
    ```ts
        //重载声明（目标函数）
        function p (name:string):string;
        //函数定义（源函数）
        function p (name:any):any{}
    ```
3. 基础类型的兼容性
    - 数字类型和null类型是兼容的
    - 枚举类型和数字类型是兼容的，枚举类型间是不兼容的。
4. 类的兼容性
    - 与函数相同只比较结构
    - 忽略静态成员和构造函数
    - 只比较实例成员
    - 如果类含有私有成员则不兼容，这时，只有父类和子类可以兼容。
5. 泛型兼容性
    - 泛型的定义相同，具体类型没指定，定义间是可以相互兼容的
    ```ts
    let a = function <T>(x:T):T{
        return x;
    }
    let b = function <U>(y:U):U{
        return y;
    }
    a = b;
    ```
### 类型保护

- 使用instanceof，判断对象类型
- 使用typeof，判断基本类型
- 使用in，判断类型字符串是否在某类型中。
- 使用as，进行类型断言
- 书写类型判断函数，简化类型断言的书写。

